C51 COMPILER V7.09   SMBUS                                                                 04/25/2008 16:22:16 PAGE 1   


C51 COMPILER V7.09, COMPILATION OF MODULE SMBUS
OBJECT MODULE PLACED IN smbus.OBJ
COMPILER INVOKED BY: D:\Keil\C51\BIN\C51.EXE smbus.C LARGE BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include "mcu.h"
   2          #include "datastruct.h"
   3          #include "kernel.h"
   4          #include "smbus.h"
   5          
   6          char bdata flag_eeprom0,flag_eeprom1;
   7          sbit f_save_system_param                                                = flag_eeprom0^0;               // 
   8          sbit f_save_lamp_group_setting                                  = flag_eeprom0^1;               // 
   9          sbit f_save_detector_setting                                    = flag_eeprom0^2;               // 
  10          sbit f_save_phase_plan                                                  = flag_eeprom0^3;               // 
  11          sbit f_save_timming_plan                                                = flag_eeprom0^4;               // 
  12          sbit f_save_schedule_plan                                               = flag_eeprom0^5;               // 
  13          sbit f_save_special_day                                                 = flag_eeprom0^6;               // 
  14          sbit f_save_multiple_schedule_control_param     = flag_eeprom0^7;               // 
  15          
  16          sbit f_save_actuate_control_param                               = flag_eeprom1^0;               // 
  17          sbit f_save_cordless_coordinate_control_param   = flag_eeprom1^1;               // 
  18          sbit f_save_comm_param                                                  = flag_eeprom1^2;               // 
  19          sbit f_save_control_mode_selection                              = flag_eeprom1^3;               // 
  20          sbit f_save_config_data                                                 = flag_eeprom1^4;               //
  21          sbit f_save_green_conflict                                              = flag_eeprom1^5;
  22          
  23          bit f_load_config_data;
  24          bit f_set_time;                                                                 // 有数据要写入 RTC 标志
  25          bit f_rd_rtc_now;                                                               // 正在读系统时间标志
  26          bit f_page_wr;                                                                  // 页写标志
  27          bit f_eeprom_rd;                                                                // 有数据要从 EEPROM 读标志
  28          bit f_rd_eeprom_now;                                                    // 正在读 EEPROM 标志 
  29          bit f_step_all;                                                                 // 准备读 EEPROM 中的某相位表总步数标志位
  30          
  31          bit f_save_err;
  32          extern bit f_manual;
  33          
  34          unsigned char write_rtc_buff[7];                                // 修改系统时间数据缓冲
  35          
  36          unsigned int wrt_num;
  37          unsigned int rdt_num,rdt_num_bak;
  38          unsigned char xdata *start_addr_ram;
  39          unsigned int start_addr_eeprom,start_addr_phase_plan_no;
  40          unsigned char save_phase_plane_table[6][12];
  41          unsigned char phase_plan_no,phase_plan_no_step,timming_plan_no,schedule_plan_no,comm_param_no,step_all_ram
             -;
  42          
  43          unsigned int err_count;
  44          unsigned char err_buf[6],m_soft_error_bak,m_hard_error_bak;
  45          
  46          void save_err(void);
  47          void err_data(unsigned char ctemp);
  48          
  49          void fun_smbus(void);
  50          void fun_write_rtc(void);
  51          void get_system_time(void);
  52          void fun_write_EEPROM(void);
  53          int set_system_time(date_time_t *dt);
  54          void display_status(unsigned char ctemp1,unsigned char ctemp2); 
C51 COMPILER V7.09   SMBUS                                                                 04/25/2008 16:22:16 PAGE 2   

  55          void SM_Receive(unsigned char chip_select, unsigned int byte_address,unsigned char rd_count,bit f_addr);
  56          void SM_Send(unsigned char chip_select, unsigned int byte_address, unsigned char wr_count,bit f_addr);
  57          
  58          /*********************************************************************************************
  59          *       原型：void SM_Send(unsigned char chip_select, unsigned int byte_address, unsigned char wr_count,bit f_ad
             -dr)
  60          *       功能: SMBUS(IIC) 发送子程序
  61          *       说明：发送 wr_count 个字节，f_addr 为 0 表示字节地址为 8 位，为 1 则为 16 位地址
  62          *       参数：无                  
  63          *       返回：无                  
  64          *********************************************************************************************/
  65          void SM_Send(unsigned char chip_select, unsigned int byte_address, unsigned char wr_count,bit f_addr)
  66          {                             
  67   1              SMB0CN = 0x44;                                                                  // SMBus enabled,ACK on acknowledge cycle
  68   1              SMB_WR_NUM_C = 0x00;         
  69   1              SMB_WR_NUM_BAK = wr_count;   
  70   1              COMMAND = (chip_select | WRITE);                                // Chip select + WRITE
  71   1              
  72   1              if (f_addr) {
  73   2                      ADDR_NUMBER = 2;                                                        // 2 address bytes
  74   2                      HIGH_ADD = ((byte_address >> 8) & 0x00FF);      // Upper 8 address bits
  75   2                      LOW_ADD = (byte_address & 0x00FF);                      // Lower 8 address bits
  76   2                      }
  77   1              else {
  78   2                      ADDR_NUMBER = 1;                                                        // 1 address bytes
  79   2                      HIGH_ADD = (byte_address & 0x00FF);                     // 8 address bits
  80   2                      }
  81   1              STO = 0;
  82   1              STA = 1;                                                                                // Start transfer
  83   1              if (COMMAND == SLAVE_LCD) f_lcd = 1;
  84   1      //0705（送到 LCD 显示）                 if (COMMAND == SLAVE_LCD) f_lcd = 1;                                                            
  85   1              SM_BUSY = 1;                                                                    // Occupy SMBus (set to busy)
  86   1              }
  87          
  88          /*********************************************************************************************
  89          *       原型：void SM_Receive (unsigned char chip_select, unsigned int byte_address,unsigned char rd_count,bit f
             -_addr)
  90          *       功能: SMBUS(IIC) 接收子程序
  91          *       说明：接收 rd_count 个字节，f_addr 为 0 表示字节地址为 8 位，为 1 则为 16 位地址
  92          *       参数：无
  93          *       返回：无
  94          *********************************************************************************************/
  95          void SM_Receive(unsigned char chip_select, unsigned int byte_address,unsigned char rd_count,bit f_addr)
  96          {
  97   1              SMB0CN = 0x44;                                                                  // SMBus enabled, ACK on acknowledge cycle
  98   1              SMB_RD_NUM_C = 0x00;
  99   1              SMB_RD_NUM_BAK = rd_count;                                                      
 100   1              COMMAND = (chip_select | READ);                                 // Chip select + READ
 101   1              
 102   1              if (f_addr) {
 103   2                      ADDR_NUMBER = 2;                                                        // 2 address bytes
 104   2                      HIGH_ADD = ((byte_address >> 8) & 0x00FF);      // Upper 8 address bits
 105   2                      LOW_ADD = (byte_address & 0x00FF);                      // Lower 8 address bits
 106   2                      }
 107   1              else {
 108   2                      ADDR_NUMBER = 1;                                                        // 1 address bytes
 109   2                      HIGH_ADD = (byte_address & 0x00FF);                     // 8 address bits
 110   2                      }
 111   1              STO = 0;
 112   1              STA = 1;                                                                                // Start transfer
 113   1              SM_BUSY = 1;                                                                    // Occupy SMBus (set to busy)
 114   1              }
C51 COMPILER V7.09   SMBUS                                                                 04/25/2008 16:22:16 PAGE 3   

 115                  
 116          //061016/*********************************************************************************************
 117          //061016*       原型：void display_status(unsigned char ctemp)
 118          //061016*       功能：
 119          //061016*       说明：
 120          //061016*       参数：无
 121          //061016*       返回：无
 122          //061016*********************************************************************************************/
 123          //061016void display_status(unsigned char ctemp1,unsigned char ctemp2) 
 124          //061016{
 125          //061016        if (!SM_BUSY) {
 126          //061016                BUFF_SMB_TR[0] = (ctemp1 / 100) % 10;
 127          //061016                BUFF_SMB_TR[1] = (ctemp1 / 10) % 10; 
 128          //061016                BUFF_SMB_TR[2] = ctemp1 % 10; 
 129          //061016                BUFF_SMB_TR[3] = (ctemp2 / 100) % 10;
 130          //061016                BUFF_SMB_TR[4] = (ctemp2 / 10) % 10; 
 131          //061016                BUFF_SMB_TR[5] = ctemp2 % 10;  
 132          //061016                SM_Send(SLAVE_LCD,0xe01a,0x06,1);
 133          //061016                }
 134          //061016        }
 135          
 136          /*********************************************************************************************
 137          *       原型：int set_system_time(date_time_t *dt)
 138          *       功能: 将设定的系统时间存入缓冲区
 139          *       说明：
 140          *       参数：无                  
 141          *       返回：无                  
 142          *********************************************************************************************/
 143          int set_system_time(date_time_t *dt)
 144          {
 145   1              f_set_time = 1;
 146   1              write_rtc_buff[0] = (((*dt).m_second / 10) << 4) | ((*dt).m_second % 10);
 147   1              write_rtc_buff[1] = (((*dt).m_minute / 10) << 4) | ((*dt).m_minute % 10);
 148   1              write_rtc_buff[2] = (((*dt).m_hour / 10) << 4) | ((*dt).m_hour % 10);
 149   1              if ((*dt).m_weekday == 0x00) write_rtc_buff[3] = 0x07;
 150   1              write_rtc_buff[3] = (*dt).m_weekday;
 151   1              write_rtc_buff[4] = (((*dt).m_day / 10) << 4) | ((*dt).m_day % 10);
 152   1              write_rtc_buff[5] = (((*dt).m_month / 10) << 4) | ((*dt).m_month % 10);
 153   1              write_rtc_buff[6] = (((*dt).m_year[1] / 10) << 4) | ((*dt).m_year[1] % 10);
 154   1              return 0;
 155   1              }
 156          
 157          /*********************************************************************************************
 158          *       原型：void fun_write_rtc(void)
 159          *       功能: 将缓冲区的系统时间写入 RTC
 160          *       说明：
 161          *       参数：无                  
 162          *       返回：无                  
 163          *********************************************************************************************/
 164          void fun_write_rtc(void) 
 165          {
 166   1              f_set_time = 0;
 167   1              BUFF_SMB_TR[0] = write_rtc_buff[0];
 168   1              BUFF_SMB_TR[1] = write_rtc_buff[1];
 169   1              BUFF_SMB_TR[2] = write_rtc_buff[2];
 170   1              BUFF_SMB_TR[3] = write_rtc_buff[3];
 171   1              BUFF_SMB_TR[4] = write_rtc_buff[4];
 172   1              BUFF_SMB_TR[5] = write_rtc_buff[5];
 173   1              BUFF_SMB_TR[6] = write_rtc_buff[6];
 174   1              SM_Send(CHIP_RTC,0x0001,0x07,0);
 175   1              }
 176          
C51 COMPILER V7.09   SMBUS                                                                 04/25/2008 16:22:16 PAGE 4   

 177          /*********************************************************************************************
 178          *       原型：int save_config_data()
 179          *       功能: 保存系统配置参数
 180          *       说明：
 181          *       参数：无                  
 182          *       返回：无                  
 183          *********************************************************************************************/
 184          int save_config_data()
 185          {
 186   1              f_save_config_data = 1;
 187   1              return 0;
 188   1              }
 189          
 190          /*********************************************************************************************
 191          *       原型：int save_system_param()
 192          *       功能: 
 193          *       说明：占用 1 + 3 * 32  共 97 个字节
 194          *       参数：无                  
 195          *       返回：无                  
 196          *********************************************************************************************/
 197          int save_system_param()
 198          {
 199   1              f_save_system_param = 1;
 200   1              }
 201          
 202          /*********************************************************************************************
 203          *       原型：int save_lamp_group_setting()
 204          *       功能: 保存灯组设置信息
 205          *       说明：占用 1 + 3 * 32  共 97 个字节
 206          *       参数：无                  
 207          *       返回：无                  
 208          *********************************************************************************************/
 209          int save_lamp_group_setting()
 210          {
 211   1              f_save_lamp_group_setting = 1;
 212   1              }
 213          
 214          /*********************************************************************************************
 215          *       原型：int save_detector_setting()
 216          *       功能: 
 217          *       说明：占用 1 + 3 * 32  共 97 个字节
 218          *       参数：无                  
 219          *       返回：无                  
 220          *********************************************************************************************/
 221          int save_detector_setting()
 222          {
 223   1              f_save_detector_setting = 1;
 224   1              }
 225          
 226          /*********************************************************************************************
 227          *       原型：int save_phase_plan(int plan_no,int step)
 228          *       功能: 
 229          *       说明：占用 1 + 3 * 32  共 97 个字节
 230          *       参数：无                  
 231          *       返回：无                  
 232          *********************************************************************************************/
 233          int save_phase_plan(int plan_no,int step)
 234          {
 235   1      unsigned char ctemp1,ctemp2,i,j;
 236   1              ctemp2 = (char)step;
 237   1              j = (ctemp2-1) % 8;
 238   1              ctemp1 = 0x01;
C51 COMPILER V7.09   SMBUS                                                                 04/25/2008 16:22:16 PAGE 5   

 239   1              for (i=0x00;i<j;i++) {
 240   2                      ctemp1 = ctemp1 << 1;
 241   2                      }
 242   1              i = (ctemp2 - 1) / 8;
 243   1              ctemp2 = (char)plan_no; 
 244   1              ctemp2--;
 245   1              save_phase_plane_table[ctemp2][i] = save_phase_plane_table[ctemp2][i] | ctemp1;
 246   1              
 247   1      //      f_save_phase_plan = 1;
 248   1              }
 249          
 250          /*********************************************************************************************
 251          *       原型：void get_save_phase_plan(void)
 252          *       功能: 
 253          *       说明：
 254          *       参数：无                  
 255          *       返回：无                  
 256          *********************************************************************************************/
 257          void get_save_phase_plan(void)
 258          {
 259   1      unsigned char i,j,k,ctemp;
 260   1              if (!(f_save_phase_plan | f_step_all | f_step_all_ok)) {
 261   2                      for (i=0x00;i<6;i++) {
 262   3                              for (j=0x00;j<12;j++) {
 263   4                                      if (save_phase_plane_table[i][j] != 0x00) {
 264   5                                              ctemp = 0x01;
 265   5                                              for (k=0x00;k<8;k++) {
 266   6                                                      if ((save_phase_plane_table[i][j] & ctemp) != 0x00) {
 267   7                                                              save_phase_plane_table[i][j] = save_phase_plane_table[i][j] & (~ctemp);
 268   7                                                              phase_plan_no = i + 1;
 269   7                                                              phase_plan_no_step = 1 + j * 8 + k;
 270   7                                                              f_save_phase_plan = 1;                                                  
 271   7                                                              return;
 272   7                                                              }
 273   6                                                      ctemp = ctemp << 1;
 274   6                                                      }
 275   5                                              } 
 276   4                                      }
 277   3                              }                       
 278   2                      }
 279   1              }
 280          
 281          
 282          /*********************************************************************************************
 283          *       原型：int save_timming_plan(int plan_no)
 284          *       功能: 
 285          *       说明：占用 1 + 3 * 32  共 97 个字节
 286          *       参数：无                  
 287          *       返回：无                  
 288          *********************************************************************************************/
 289          int save_timming_plan(int plan_no)
 290          {
 291   1              timming_plan_no = (char)plan_no;
 292   1              f_save_timming_plan = 1;
 293   1              }
 294          
 295          /*********************************************************************************************
 296          *       原型：int save_schedule_plan(int plan_no)
 297          *       功能: 
 298          *       说明：占用 1 + 3 * 32  共 97 个字节
 299          *       参数：无                  
 300          *       返回：无                  
C51 COMPILER V7.09   SMBUS                                                                 04/25/2008 16:22:16 PAGE 6   

 301          *********************************************************************************************/
 302          int save_schedule_plan(int plan_no)
 303          {
 304   1              schedule_plan_no = (char)plan_no;
 305   1              f_save_schedule_plan = 1;
 306   1              }
 307          
 308          /*********************************************************************************************
 309          *       原型：int save_special_day()
 310          *       功能: 
 311          *       说明：占用 1 + 3 * 32  共 97 个字节
 312          *       参数：无                  
 313          *       返回：无                  
 314          *********************************************************************************************/
 315          int save_special_day()
 316          {
 317   1              f_save_special_day = 1;
 318   1              }
 319          
 320          /*********************************************************************************************
 321          *       原型：int save_multiple_schedule_control_param()
 322          *       功能: 
 323          *       说明：占用 1 + 3 * 32  共 97 个字节
 324          *       参数：无                  
 325          *       返回：无                  
 326          *********************************************************************************************/
 327          int save_multiple_schedule_control_param()
 328          {
 329   1              f_save_multiple_schedule_control_param = 1;
 330   1              }
 331          
 332          /*********************************************************************************************
 333          *       原型：int save_actuate_control_param()
 334          *       功能: 
 335          *       说明：占用 1 + 3 * 32  共 97 个字节
 336          *       参数：无                  
 337          *       返回：无                  
 338          *********************************************************************************************/
 339          int save_actuate_control_param()
 340          {
 341   1              f_save_actuate_control_param = 1;
 342   1              }
 343          
 344          /*********************************************************************************************
 345          *       原型：int save_cordless_coordinate_control_param()
 346          *       功能: 
 347          *       说明：占用 1 + 3 * 32  共 97 个字节
 348          *       参数：无                  
 349          *       返回：无                  
 350          *********************************************************************************************/
 351          int save_cordless_coordinate_control_param()
 352          {
 353   1              f_save_cordless_coordinate_control_param = 1;
 354   1              }
 355          
 356          /*********************************************************************************************
 357          *       原型：int save_comm_param(int param_no)
 358          *       功能: 
 359          *       说明：占用 1 + 3 * 32  共 97 个字节
 360          *       参数：无                  
 361          *       返回：无                  
 362          *********************************************************************************************/
C51 COMPILER V7.09   SMBUS                                                                 04/25/2008 16:22:16 PAGE 7   

 363          int save_comm_param(int param_no)
 364          {
 365   1              comm_param_no = (char)param_no;
 366   1              f_save_comm_param = 1;
 367   1              }
 368          
 369          /*********************************************************************************************
 370          *       原型：int save_control_mode_selection()
 371          *       功能: 
 372          *       说明：占用 1 + 3 * 32  共 97 个字节
 373          *       参数：无                  
 374          *       返回：无                  
 375          *********************************************************************************************/
 376          int save_control_mode_selection()
 377          {
 378   1              f_run_mode = 0;                                                                         // 以中心设定模式运行
 379   1              f_save_control_mode_selection = 1;
 380   1              }
 381          
 382          /*********************************************************************************************
 383          *       原型：int save_green_conflict()
 384          *       功能: 
 385          *       说明：
 386          *       参数：无                  
 387          *       返回：无                  
 388          *********************************************************************************************/
 389          int save_green_conflict()
 390          {
 391   1              f_save_green_conflict = 1;
 392   1              }
 393          
 394          /*********************************************************************************************
 395          *       原型：void save_err(void)
 396          *       功能: 保存故障的类型及发生、解除时间
 397          *       说明：故障类型的最高位(B7)为 1 表示故障发生，为 0 表示故障解除
 398          *       参数：无                  
 399          *       返回：无                  
 400          *********************************************************************************************/
 401          void save_err(void)
 402          {
 403   1      unsigned char ctemp0,ctemp1,i;
 404   1              if (f_wr_eeprom_now | SM_BUSY) return;  
 405   1              if (err_count >= err_count_max) return;                                                                         // EEPROM 空间已满不能再存放数据
 406   1              if (m_hard_error_bak != g_controller_status.m_error.m_hard_error) {                     // 硬件故障
 407   2                      ctemp0 = m_hard_error_bak ^ g_controller_status.m_error.m_hard_error;
 408   2                      ctemp1 = 0x01;
 409   2                      for (i=0x00;i<8;i++) {
 410   3                              if ((ctemp0 & ctemp1) != 0x00) break;
 411   3                              ctemp1 = ctemp1 << 1;
 412   3                              }
 413   2                      if ((m_hard_error_bak & ctemp1) != 0x00) m_hard_error_bak = m_hard_error_bak & (~ctemp1);       // 故障解除
 414   2                      else {                                                                                                                                  // 故障发生
 415   3                              i = i + 0x80;
 416   3                              m_hard_error_bak = m_hard_error_bak | ctemp1;
 417   3                              }
 418   2                      err_data(i+1);
 419   2                      return;
 420   2                      } 
 421   1              if (m_soft_error_bak != g_controller_status.m_error.m_soft_error) {                     // 软件故障
 422   2                      ctemp0 = m_soft_error_bak ^ g_controller_status.m_error.m_soft_error;
 423   2                      ctemp1 = 0x01;
 424   2                      for (i=0x00;i<8;i++) {
C51 COMPILER V7.09   SMBUS                                                                 04/25/2008 16:22:16 PAGE 8   

 425   3                              if ((ctemp0 & ctemp1) != 0x00) break;
 426   3                              ctemp1 = ctemp1 << 1;
 427   3                              }
 428   2                      if ((m_soft_error_bak & ctemp1) != 0x00) m_soft_error_bak = m_soft_error_bak & (~ctemp1);       // 故障解除
 429   2                      else {                                                                                                                                  // 故障发生
 430   3                              i = i + 0x80;
 431   3                              m_soft_error_bak = m_soft_error_bak | ctemp1;
 432   3                              }
 433   2                      err_data(i+17);
 434   2                      } 
 435   1              }
 436          
 437          /*********************************************************************************************
 438          *       原型：void err_data(unsigned char ctemp)
 439          *       功能: 故障内容
 440          *       说明：
 441          *       参数：无                  
 442          *       返回：无                  
 443          *********************************************************************************************/
 444          void err_data(unsigned char ctemp)
 445          {
 446   1              f_save_err = 1;
 447   1              err_buf[0] = ctemp;
 448   1              err_buf[1] = g_controller_status.m_month;
 449   1              err_buf[2] = g_controller_status.m_day;
 450   1              err_buf[3] = g_controller_status.m_hour;
 451   1              err_buf[4] = g_controller_status.m_minute;      
 452   1              err_buf[5] = g_controller_status.m_second;
 453   1              }
 454                  
 455          /*********************************************************************************************
 456          *       原型：void fun_smbus(void)
 457          *       功能: 判断是否有数据要写入 EEPROM，并在 SMBUS 空闲时启动写入
 458          *       说明：
 459          *       参数：无                  
 460          *       返回：无                  
 461          *********************************************************************************************/
 462          void fun_smbus(void)
 463          {
 464   1      unsigned int intemp,intemp1;
 465   1              
 466   1              if (SM_BUSY) return;                                                                                    // SMBUS 忙
 467   1      
 468   1              if (f_set_time) {
 469   2                      fun_write_rtc();                                                                                        // 写 RTC 
 470   2                      return;
 471   2                      }
 472   1              if (!f_wr_eeprom_now) {
 473   2                      
 474   2                      if (f_step_all_ok) {                                                                            // 保存某相位表的总步数
 475   3                              f_step_all_ok = 0;
 476   3                              if (step_all_ram != step_all_flash) {
 477   4                                      BUFF_SMB_TR[0] = step_all_ram;
 478   4                                      SM_Send(CHIP_EEPROM,start_addr_phase_plan_no,0x01,1);
 479   4                                      return;
 480   4                                      }
 481   3                              }
 482   2                      
 483   2                      
 484   2                      if (f_page_wr) fun_write_EEPROM();                                                      // 后序页写
 485   2                      else {
 486   3                              if (f_eeprom_rd) {                                                                              // 有数据要从 EEPROM 读 
C51 COMPILER V7.09   SMBUS                                                                 04/25/2008 16:22:16 PAGE 9   

 487   4                                      if (!f_rd_eeprom_now) { 
 488   5      //                                      f_eeprom_rd = 0;
 489   5                                              if (f_load_config_data) {
 490   6                                                      f_rd_eeprom_now = 1;
 491   6                                                      f_load_config_data = 0;
 492   6                                                      rdt_num = 0x00;
 493   6                                                      rdt_num_bak = ee_size0; 
 494   6                                                      start_addr_ram = &g_config.m_system_param;
*** WARNING C182 IN LINE 494 OF SMBUS.C: pointer to different objects
 495   6                                                      SM_Receive(CHIP_EEPROM,g_config_addr,0x80,1);
 496   6                                                      return;         
 497   6                                                      }
 498   5                                              if (f_step_all) {
 499   6                                                      rdt_num_bak = 0x01;     
 500   6                                                      f_rd_eeprom_now = 1;
 501   6                                                      SM_Receive(CHIP_EEPROM,start_addr_phase_plan_no,0x01,1);
 502   6                                                      return; 
 503   6                                                      }
 504   5                                              }
 505   4                                      }
 506   3                              else {
 507   4                                      if (flag_eeprom0 | flag_eeprom1) {                                      // 有数据要写入 EEPROM
 508   5                                              if (f_save_config_data) {
 509   6                                                      flag_eeprom0 = 0x00;
 510   6                                                      flag_eeprom1 = 0x00;
 511   6                                                      start_addr_eeprom = g_config_addr;
 512   6                                                      wrt_num = ee_size0;     
 513   6                                                      start_addr_ram = &g_config.m_system_param;
*** WARNING C182 IN LINE 513 OF SMBUS.C: pointer to different objects
 514   6                                                      fun_write_EEPROM();             
 515   6                                                      return;         
 516   6                                                      }                       
 517   5                                              if (f_save_system_param) {
 518   6                                                      f_save_system_param = 0;
 519   6                                                      start_addr_eeprom = m_system_param_addr;
 520   6                                                      wrt_num = ee_size1;     
 521   6                                                      start_addr_ram = &g_config.m_system_param;
*** WARNING C182 IN LINE 521 OF SMBUS.C: pointer to different objects
 522   6                                                      fun_write_EEPROM();
 523   6                                                      return;
 524   6                                                      }
 525   5                                              if (f_save_lamp_group_setting) {
 526   6                                                      f_save_lamp_group_setting = 0;
 527   6                                                      start_addr_eeprom = m_lamp_group_setting_addr;
 528   6                                                      wrt_num = ee_size2;     
 529   6                                                      start_addr_ram = &g_config.m_lamp_group_setting;
*** WARNING C182 IN LINE 529 OF SMBUS.C: pointer to different objects
 530   6                                                      fun_write_EEPROM();
 531   6                                                      return;
 532   6                                                      }
 533   5                                              if (f_save_detector_setting) {
 534   6                                                      f_save_detector_setting = 0;
 535   6                                                      start_addr_eeprom = m_detector_setting_addr;
 536   6                                                      wrt_num = ee_size3;     
 537   6                                                      start_addr_ram = &g_config.m_detector_setting;
*** WARNING C182 IN LINE 537 OF SMBUS.C: pointer to different objects
 538   6                                                      fun_write_EEPROM();
 539   6                                                      return;
 540   6                                                      }
 541   5                                              if (f_save_phase_plan) {
 542   6                                                      f_save_phase_plan = 0;
 543   6                                                      intemp = (phase_plan_no - 1) * ee_size4a;
C51 COMPILER V7.09   SMBUS                                                                 04/25/2008 16:22:16 PAGE 10  

 544   6                                                      intemp1 = (phase_plan_no_step - 1) * ee_size4b;
 545   6                                                      start_addr_phase_plan_no = m_phase_table_addr + intemp;                 // 某相位表在 FLASH 中的首地址
 546   6                                                      start_addr_eeprom = start_addr_phase_plan_no + intemp1 + 1;             // 某相位表的第 phase_plan_no_step 步在
             - FLASH 中的首地址
 547   6                                                      wrt_num = ee_size4b;    
 548   6                                                      start_addr_ram = &g_config.m_phase_table;
*** WARNING C182 IN LINE 548 OF SMBUS.C: pointer to different objects
 549   6                                                      start_addr_ram = start_addr_ram + intemp;                                               // 某相位表在内存中的首地址
 550   6                                                      step_all_ram = *start_addr_ram;                                                                 // 某相位表在内存中保存的总步数
 551   6                                                      start_addr_ram = start_addr_ram + intemp1 + 1;                                  // 某相位表的第 phase_plan_no_step 步在内存中的首
             -地址
 552   6                                                      fun_write_EEPROM();
 553   6                                                      f_step_all = 1;
 554   6                                                      f_eeprom_rd = 1;
 555   6                                                      return;
 556   6                                                      }
 557   5                                              if (f_save_timming_plan) {
 558   6                                                      f_save_timming_plan = 0;
 559   6                                                      intemp = (timming_plan_no - 1) * ee_size5a;
 560   6                                                      start_addr_eeprom = m_timming_table_addr + intemp;
 561   6                                                      wrt_num = ee_size5a;    
 562   6                                                      start_addr_ram = &g_config.m_timming_table;
*** WARNING C182 IN LINE 562 OF SMBUS.C: pointer to different objects
 563   6                                                      start_addr_ram = start_addr_ram + intemp;
 564   6                                                      fun_write_EEPROM();
 565   6                                                      return;
 566   6                                                      }
 567   5                                              if (f_save_schedule_plan) {
 568   6                                                      f_save_schedule_plan = 0;
 569   6                                                      intemp = (schedule_plan_no - 1) * ee_size6a;
 570   6                                                      start_addr_eeprom = m_schedule_table_addr + intemp;
 571   6                                                      wrt_num = ee_size6a;    
 572   6                                                      start_addr_ram = g_config.m_schedule_table;
*** WARNING C182 IN LINE 572 OF SMBUS.C: pointer to different objects
 573   6                                                      start_addr_ram = start_addr_ram + intemp;
 574   6                                                      fun_write_EEPROM();
 575   6                                                      return;
 576   6                                                      }
 577   5                                              if (f_save_special_day) {
 578   6                                                      f_save_special_day = 0;
 579   6                                                      start_addr_eeprom = m_special_day_table_addr;
 580   6                                                      wrt_num = ee_size7;     
 581   6                                                      start_addr_ram = &g_config.m_special_day_table;
*** WARNING C182 IN LINE 581 OF SMBUS.C: pointer to different objects
 582   6                                                      fun_write_EEPROM();
 583   6                                                      return;
 584   6                                                      }
 585   5                                              if (f_save_multiple_schedule_control_param) {
 586   6                                                      f_save_multiple_schedule_control_param = 0;
 587   6                                                      start_addr_eeprom = m_multiple_schedule_control_param_addr;
 588   6                                                      wrt_num = ee_size8;     
 589   6                                                      start_addr_ram = &g_config.m_multiple_schedule_control_param;
*** WARNING C182 IN LINE 589 OF SMBUS.C: pointer to different objects
 590   6                                                      fun_write_EEPROM();
 591   6                                                      return;
 592   6                                                      }
 593   5                                              if (f_save_actuate_control_param) {
 594   6                                                      f_save_actuate_control_param = 0;
 595   6                                                      start_addr_eeprom = m_actuate_control_param_addr;
 596   6                                                      wrt_num = ee_size9;     
 597   6                                                      start_addr_ram = &g_config.m_actuate_control_param;
*** WARNING C182 IN LINE 597 OF SMBUS.C: pointer to different objects
C51 COMPILER V7.09   SMBUS                                                                 04/25/2008 16:22:16 PAGE 11  

 598   6                                                      fun_write_EEPROM();
 599   6                                                      return;
 600   6                                                      }
 601   5                                              if (f_save_cordless_coordinate_control_param) {
 602   6                                                      f_save_cordless_coordinate_control_param = 0;
 603   6                                                      start_addr_eeprom = m_cordless_coordinate_control_param_addr;
 604   6                                                      wrt_num = ee_size10;    
 605   6                                                      start_addr_ram = &g_config.m_cordless_coordinate_control_param;
*** WARNING C182 IN LINE 605 OF SMBUS.C: pointer to different objects
 606   6                                                      fun_write_EEPROM();
 607   6                                                      return;
 608   6                                                      }
 609   5                                              if (f_save_comm_param) {
 610   6                                                      f_save_comm_param = 0;
 611   6                                                      intemp = (comm_param_no - 1) * ee_size11a;
 612   6                                                      start_addr_eeprom = m_comm_param_addr + intemp;
 613   6                                                      wrt_num = ee_size11a;   
 614   6                                                      start_addr_ram = &g_config.m_comm_param;
*** WARNING C182 IN LINE 614 OF SMBUS.C: pointer to different objects
 615   6                                                      start_addr_ram = start_addr_ram + intemp;
 616   6                                                      fun_write_EEPROM();
 617   6                                                      return;
 618   6                                                      }
 619   5                                              if (f_save_control_mode_selection) {
 620   6                                                      f_save_control_mode_selection = 0;
 621   6                                                      start_addr_eeprom = m_control_mode_selection_addr;
 622   6                                                      wrt_num = ee_size12;    
 623   6                                                      start_addr_ram = &g_config.m_control_mode_selection;                    //0x44dc
*** WARNING C182 IN LINE 623 OF SMBUS.C: pointer to different objects
 624   6      // 060615
 625   6                                                      if (g_config.m_control_mode_selection.m_control_mode != 0x08) f_manual = 0;
 626   6      // 060615
 627   6                                                      fun_write_EEPROM();
 628   6                                                      return;
 629   6                                                      }
 630   5                                              if (f_save_green_conflict) {
 631   6                                                      f_save_green_conflict = 0;
 632   6                                                      start_addr_eeprom = m_green_conflict_addr;
 633   6                                                      wrt_num = ee_size13;    
 634   6                                                      start_addr_ram = &g_config.m_green_conflict;
*** WARNING C182 IN LINE 634 OF SMBUS.C: pointer to different objects
 635   6                                                      fun_write_EEPROM();
 636   6                                                      return;
 637   6                                                      }
 638   5                                              
 639   5                                              if (f_save_err) {
 640   6                                                      f_save_err = 0;
 641   6                                                      start_addr_eeprom = err_save_start_addr + err_count * err_long;
 642   6                                                      wrt_num = err_long;     
 643   6                                                      start_addr_ram = &err_buf;
 644   6                                                      fun_write_EEPROM();
 645   6                                                      err_count++;
 646   6                                                      return;
 647   6                                                      }
 648   5                                              }
 649   4                                      }
 650   3                              }
 651   2                      }
 652   1              if (wr_eeprom_count == 0x60) get_system_time();                                                 // 读取系统时间
 653   1              }
 654          
 655          /*********************************************************************************************
C51 COMPILER V7.09   SMBUS                                                                 04/25/2008 16:22:16 PAGE 12  

 656          *       原型：void fun_write_EEPROM(void)
 657          *       功能: 将缓冲区的数据写入 EEPROM
 658          *       说明：
 659          *       参数：无                  
 660          *       返回：无                  
 661          *********************************************************************************************/
 662          void fun_write_EEPROM(void)
 663          {
 664   1      unsigned char chartemp,i;
 665   1      unsigned int intemp0,intemp1;
 666   1              if (f_page_wr) {
 667   2                      intemp1 = start_addr_eeprom;
 668   2                      if (wrt_num >= 0x80) {                                                                                  // 本次仍不能将待写的字节一次性写完
 669   3                              chartemp = 0x80;                                                                                        // 页长度为 128
 670   3                              start_addr_eeprom = start_addr_eeprom + chartemp;       
 671   3                              wrt_num = wrt_num - chartemp;
 672   3                              }
 673   2                      else {                                                                                                                  // 本次可将待写的字节一次性写完
 674   3                              f_page_wr = 0;
 675   3                              chartemp = (char)wrt_num;
 676   3                              }
 677   2                      }       
 678   1              else {  
 679   2                      intemp0 = (start_addr_eeprom + wrt_num) & 0xff80; 
 680   2                      intemp0 = intemp0 ^ (start_addr_eeprom & 0xff80); 
 681   2                      intemp1 = start_addr_eeprom;                                                                    // 本次写 EEPROM 的起始地址
 682   2                      if (intemp0 != 0) {                                                                                             // 要写的数据跨页
 683   3                              f_page_wr = 1;                                                                                          // 一次写不完的标志位
 684   3                              i = (char)start_addr_eeprom;    
 685   3                              chartemp = 0x80 - (i & 0x7f);                                                           // 当前页可写的字节数，也就是本次写入 EEPROM 的字节数 
 686   3                              start_addr_eeprom = start_addr_eeprom + chartemp;                       // 下一次写 EEPROM 的起始地址
 687   3                              wrt_num = wrt_num - chartemp;                                                           // 剩下待写的字节数
 688   3                              }
 689   2                      else {
 690   3                              chartemp = (char)wrt_num;
 691   3                              }
 692   2                      }
 693   1              for (i=0x00;i<chartemp;i++) {                                                                           // 从 RAM 中读出数据放入 SMBUS 发送缓冲区
 694   2                      BUFF_SMB_TR[i] = *start_addr_ram; 
 695   2                      start_addr_ram++;
 696   2                      }
 697   1              SM_Send(CHIP_EEPROM,intemp1,chartemp,1);
 698   1              }
 699          
 700          /*********************************************************************************************
 701          *       原型：void get_system_time(void)
 702          *       功能: 读取系统时间
 703          *       说明：
 704          *       参数：无                  
 705          *       返回：无                  
 706          *********************************************************************************************/
 707          void get_system_time(void)
 708          {
 709   1      unsigned char ctemp1;
 710   1              
 711   1              if (!(f_rd_rtc_now | f_rd_smbus_ok)) {
 712   2                      f_rd_rtc_now = 1;
 713   2                      SM_Receive(CHIP_RTC,0x0001,0x07,0);                          
 714   2                      }
 715   1              if (f_rd_rtc_now | f_rd_smbus_ok) {
 716   2                      f_rd_rtc_now = 0;
 717   2                      f_rd_smbus_ok = 0;
C51 COMPILER V7.09   SMBUS                                                                 04/25/2008 16:22:16 PAGE 13  

 718   2                      ctemp1 = ((BUFF_SMB_RD[0] & 0x7f) >> 4) * 10;
 719   2                      g_controller_status.m_second = ctemp1 + (BUFF_SMB_RD[0] & 0x0f);
 720   2                      ctemp1 = (BUFF_SMB_RD[1] >> 4) * 10;
 721   2                      g_controller_status.m_minute = ctemp1 + (BUFF_SMB_RD[1] & 0x0f);
 722   2                      ctemp1 = ((BUFF_SMB_RD[2] & 0x3f) >> 4) * 10;
 723   2                      g_controller_status.m_hour = ctemp1 + (BUFF_SMB_RD[2] & 0x0f);
 724   2                      if (BUFF_SMB_RD[3] == 0x07) g_controller_status.m_week = 0x00;
 725   2                      else g_controller_status.m_week = BUFF_SMB_RD[3];
 726   2                      ctemp1 = (BUFF_SMB_RD[4] >> 4) * 10;
 727   2                      g_controller_status.m_day = ctemp1 + (BUFF_SMB_RD[4] & 0x0f);
 728   2                      ctemp1 = (BUFF_SMB_RD[5] >> 4) * 10;
 729   2                      g_controller_status.m_month = ctemp1 + (BUFF_SMB_RD[5] & 0x0f);
 730   2                      ctemp1 = (BUFF_SMB_RD[6] >> 4) * 10;
 731   2                      g_controller_status.m_year[1] = ctemp1 + (BUFF_SMB_RD[6] & 0x0f);
 732   2                      g_controller_status.m_year[0] = 20;
 733   2                      }
 734   1              }
 735          
 736          
 737          
 738          /*********************************************************************************************
 739          *       原型：int load_config_data()
 740          *       功能: 刚开机时载入系统配置参数
 741          *       说明：
 742          *       参数：无                  
 743          *       返回：无                  
 744          *********************************************************************************************/
 745          int load_config_data()
 746          {
 747   1              f_eeprom_rd = 1;
 748   1              f_load_config_data = 1;
 749   1              
 750   1      //      int i,j;
 751   1      //      timming_plan_t tm;
 752   1      //      phase_plan_t ph;
 753   1      //      // 测试多时段控制使用
 754   1      //
 755   1      //      // 设定一个时段方案
 756   1      //      schedule_plan_t sp;
 757   1      //
 758   1      //      g_config.m_control_mode_selection.m_control_mode = CONTROL_MODE_FRONT_PANEL_SELECT;
 759   1      //      
 760   1      //      sp.m_time_segment_count = 2;
 761   1      //      sp.m_hour[0]      = 0;
 762   1      //      sp.m_minute[0]    = 0;
 763   1      //      sp.m_phase[0]     = 1;
 764   1      //      sp.m_timming[0]   = 1;
 765   1      //
 766   1      //      sp.m_hour[1]      = 10;
 767   1      //      sp.m_minute[1]    = 54;
 768   1      //      sp.m_phase[1]     = 1;
 769   1      //      sp.m_timming[1]   = 1;
 770   1      //
 771   1      //      for(i=0; i<MAX_SCHEDULE_PLAN_COUNT; i++)
 772   1      //              g_config.m_schedule_table[i] = sp;
 773   1      //      
 774   1      //      //
 775   1      //      tm.m_step = 72;
 776   1      //      for(i=0; i<MAX_STEP_COUNT; i++)
 777   1      //              tm.m_timming[i] = 5;
 778   1      //      g_config.m_timming_table[0] = tm;
 779   1      //      g_config.m_timming_table[1] = tm;
C51 COMPILER V7.09   SMBUS                                                                 04/25/2008 16:22:16 PAGE 14  

 780   1      //      //
 781   1      //      ph.m_step = 72;
 782   1      //      for(i=0;i<MAX_STEP_COUNT; i++){
 783   1      //              unsigned char v;
 784   1      //              switch(i%4){
 785   1      //                              case 0:
 786   1      //                                      v = 0x40;
 787   1      //                                      break;
 788   1      //                              case 1:
 789   1      //                                      v = 0x10;
 790   1      //                                      break;
 791   1      //                              case 2:
 792   1      //                                      v = 0x04;
 793   1      //                                      break;
 794   1      //                              case 3:
 795   1      //                                      v = 0x01;
 796   1      //                                      break;
 797   1      //                              default:
 798   1      //                                      v = 0x00;
 799   1      //                      }
 800   1      //      
 801   1      //              for(j=0;j<MAX_OUTPUT_COUNT;j++){
 802   1      //                      if(j == i/4)
 803   1      //                              ph.m_phase[i].m_output[j] = v;
 804   1      //                      else
 805   1      //                              ph.m_phase[i].m_output[j] = 0;
 806   1      //              }
 807   1      //      }
 808   1      //      g_config.m_phase_table[0] = ph;
 809   1      //      g_config.m_phase_table[1] = ph;
 810   1      //      // 多段控制参数
 811   1      //      g_config.m_multiple_schedule_control_param.m_schedule_plan = 7;
 812   1      //
 813   1      //      // 初始化波特率
 814   1      //      for(i=0; i<MAX_COMM_COUNT; i++)
 815   1      //              g_config.m_comm_param[i].m_baud = B_9600;
 816   1      
 817   1              return 0;
 818   1      
 819   1              }
 820          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2339    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    107       7
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      8       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  15 WARNING(S),  0 ERROR(S)
